<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Program Questions</title>
    <link rel="stylesheet" href="style.css"> <!-- Link to external CSS -->
    <script>
        function showProgram(questionNumber) {
            // Hide all code and output sections
            document.querySelectorAll('.code-container, .output-container').forEach((el) => {
                el.style.display = 'none';
            });

            // Show the selected question's code and output
            document.getElementById('code' + questionNumber).style.display = 'block';
            document.getElementById('output' + questionNumber).style.display = 'block';

            // Show the code-output container
            document.getElementById('output-container').style.display = 'flex';
        }
    </script>
</head>
<body>
    <nav>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="program.html">Programs</a></li>
            <li><a href="contact.html">Contact</a></li>
        </ul>
    </nav>
    <div class="container">
        <div class="question-list">
            <h2>Queue Programs:</h2>
            <li><a href="#" onclick="showProgram(1)">1. Implement the operations of simple queue in an integer array (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(2)">2. Implement the operations of simple queue in a string array (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(3)">3. Implement the operations of queue dynamically of integers (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(4)">4. Implement the operations of queue dynamically of strings (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(5)">5. Implement the operations of circular queue in an integer array (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(6)">6. Implement the operations of circular queue in a string array (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(7)">7. Implement the operations of priority queue in an integer array (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(8)">8. Implement the operations of priority queue in a string array (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(9)">9. Implement the operations of double ended queue in an integer array (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(10)">10. Implement the operations of double ended queue in a string array (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(11)">11. Implement the operations of priority queue dynamically of integers (insert, delete, peek, isEmpty, isFull)</a></li>
            <li><a href="#" onclick="showProgram(12)">12. Implement the operations of priority queue dynamically of strings (insert, delete, peek, isEmpty, isFull)</a></li>
            
<li><a href="#" onclick="showProgram(13)">13. Find the first circular tour that visits all petrol pumps

Explanation -Given information about N petrol pumps (say arr[]) that are present in a circular path. The information consists of the distance of the next petrol pump from the current one (in arr[i][1]) and the amount of petrol stored in that petrol pump (in arr[i][0]). Consider a truck with infinite capacity that consumes 1 unit of petrol to travel 1 unit distance. The task is to find the index of the first starting point such that the truck can visit all the petrol pumps and come back to that starting point. Note: Return -1 if no such tour exists. Examples: Input: arr[] = {{4, 6}, {6, 5}, {7, 3}, {4, 5}}. Output: 1 Explanation: If started from 1st index then a circular tour can be covered. Input: arr[] {{6, 4}, {3, 6}, {7, 3}} Output: 2
</a></li>


<li><a href="#" onclick="showProgram(14)">14. Length of the longest valid substring

Explanation -Given a string consisting of opening and closing parenthesis, find the length of the longest valid parenthesis substring. Examples: Input : ((() Output : 2 Explanation : () Input: )()()) Output : 4 Explanation: ()() Input: ()(())))) Output: 6 Explanation: ()(())

</a></li>

<li><a href="#" onclick="showProgram(15)">15. Find the Next Greater Element

    Explanation -Given an array arr[ ] of size N having elements, the task is to find the next greater element for each element of the array in order of their appearance in the array. Next greater element of an element in the array is the nearest element on the right which is greater than the current element. If there does not exist next greater of current element, then next greater element for current element is -1. For example, next greater of the last element is always -1. Example 1: Input: N = 4, arr[] = [1 3 2 4] Output: 3 4 4 -1 Explanation: In the array, the next larger element to 1 is 3 , 3 is 4 , 2 is 4 and for 4 ? since it doesn't exist, it is -1. Example 2: Input: N = 5, arr[] [6 8 0 1 3] Output: 8 -1 1 3 -1 Explanation: In the array, the next larger element to 6 is 8, for 8 there is no larger elements hence it is -1, for 0 it is 1 , for 1 it is 3 and then for 3 there is no larger element on right and hence -1.
    
    
    </a></li>
    
    <li><a href="#" onclick="showProgram(16)">16. Find Next Smaller Element
    
    Explanation -Given an array, print the Next Smaller Element (NSE) for every element. The NSE for an element x is the first smaller element on the right side of x in the array. Elements for which no smaller element exist (on the right side), consider NSE as -1. Examples: Input: [4, 8, 5, 2, 25] Output: [2, 5, 2, -1, -1] Explanation: The first element smaller than 4 having index > 0 is 2. The first element smaller than 8 having index > 1 is 5. The first element smaller than 5 having index > 2 is 2. There are no elements smaller than 4 having index > 3. There are no elements smaller than 4 having index > 4. Input: [13, 7, 6, 12] Output: [7, 6, -1, -1] Explanation: The first element smaller than 13 having index > 0 is 7. The first element smaller than 7 having index > 1 is 6. There are no elements smaller than 6 having index > 2. There are no elements smaller than 12 having index > 3.
    </a></li>
    
    
    
    
    
    <li><a href="#" onclick="showProgram(17)">17. Queue based approach for first non-repeating character in a stream
    
    Explanation -Given a stream of characters and we have to find first non repeating character each time a character is inserted to the stream. Examples: Input : a a b c Output : a -1 b b Input : a a c Output : a -1 c
    
    </a></li>
    
    <li><a href="#" onclick="showProgram(18)">18. Reverse First K elements of Queue
    
    Explanation -Given an integer K and a queue of integers, we need to reverse the order of the first K elements of the queue, leaving the other elements in the same relative order. Only following standard operations are allowed on queue. enqueue(x) : Add an item x to rear of queue dequeue() : Remove an item from front of queue size() : Returns number of elements in queue. front() : Finds front item. Note: The above operations represent the general processings. In-built functions of the respective languages can be used to solve the problem. Example 1: Input: 5 3 1 2 3 4 5 Output: 3 2 1 4 5 Explanation: After reversing the given input from the 3rd position the resultant output will be 3 2 1 4 5. Example 2: Input: 4 4 4 3 2 1 Output: 1 2 3 4 Explanation: After reversing the given input from the 4th position the resultant output will be 1 2 3 4.
    
    
    
    
    
    </a></li>
    <li><a href="#" onclick="showProgram(19)">19. Queue Reversal
    
    Explanation -Given a Queue Q containing N elements. The task is to reverse the Queue. Your task is to complete the function rev(), that reverses the N elements of the queue. Example 1: Input: 6 4 3 1 10 2 6 Output: 6 2 10 1 3 4 Explanation: After reversing the given elements of the queue , the resultant queue will be 6 2 10 1 3 4. Example 2: Input: 4 4 3 2 1 Output: 1 2 3 4 Explanation: After reversing the given elements of the queue , the resultant queue will be 1 2 3 4.
    </a></li>
    
    
    <li><a href="#" onclick="showProgram(20)">20. Rotten Oranges
    
    Explanation -
    
    Given a grid of dimension nxm where each cell in the grid can have values 0, 1 or 2 which has the following meaning: 0 : Empty cell 1 : Cells have fresh oranges 2 : Cells have rotten oranges We have to determine what is the earliest time after which all the oranges are rotten. A rotten orange at index [i,j] can rot other fresh orange at indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] (up, down, left and right) in unit time. Example 1: Input: grid = {{0,1,2},{0,1,2},{2,1,1}} Output: 1 Explanation: The grid is- 0 1 2 0 1 2 2 1 1 Oranges at positions (0,2), (1,2), (2,0) will rot oranges at (0,1), (1,1), (2,2) and (2,1) in unit time. Example 2: Input: grid = {{2,2,0,1}} Output: -1 Explanation: The grid is- 2 2 0 1 Oranges at (0,0) and (0,1) can't rot orange at (0,3).
    
    </a></li>
    
      </ul>
            </div>
            <div class="code-output-container" id="output-container">
                <div class="code-container" id="code1">
                    <h2><center></u>Code for Question 1</center></u></h2>
                    <pre><code><center>
    
    #include < stdio.h >
    #define MAX 5 
    int main() {
        int queue[MAX];  
        int front = -1;  
        int rear = -1;   
        int choice, value;
    
        
        int isEmpty() {
            return (front == -1);
        }
    
        
        int isFull() {
            return (rear == MAX - 1);
        }
    
      
        void insert(int value) {
            if (isFull()) {
                printf("Queue is full! Cannot insert %d.\n", value);
            } else {
                if (isEmpty()) {
                    front = 0; 
                }
                rear++;
                queue[rear] = value;
                printf("%d inserted into the queue.\n", value);
            }
        }
    
        
        int delete() {
            if (isEmpty()) {
                printf("Queue is empty! Cannot delete.\n");
                return -1; 
            } else {
                int value = queue[front];
                
                if (front == rear) {
                    front = -1;
                    rear = -1;
                } else {
                    front++;
                }
                printf("%d deleted from the queue.\n", value);
                return value;
            }
        }
    
       
        int peek() {
            if (isEmpty()) {
                printf("Queue is empty! Nothing to peek.\n");
                return -1; 
            } else {
                return queue[front];
            }
        }
    
      
        do {
            printf("\nQueue Operations Menu:\n");
            printf("1. Insert\n");
            printf("2. Delete\n");
            printf("3. Peek\n");
            printf("4. Check if Empty\n");
            printf("5. Check if Full\n");
            printf("6. Exit\n");
            printf("Enter your choice: ");
            scanf("%d", &choice);
    
            switch (choice) {
                case 1: // Insert
                    printf("Enter value to insert: ");
                    scanf("%d", &value);
                    insert(value);
                    break;
                case 2: // Delete
                    delete();
                    break;
                case 3: // Peek
                    value = peek();
                    if (value != -1) {
                        printf("Front element is: %d\n", value);
                    }
                    break;
                case 4: 
                    if (isEmpty()) {
                        printf("Queue is empty.\n");
                    } else {
                        printf("Queue is not empty.\n");
                    }
                    break;
                case 5:
                    if (isFull()) {
                        printf("Queue is full.\n");
                    } else {
                        printf("Queue is not full.\n");
                    }
                    break;
                case 6: 
                    printf("Exiting...\n");
                    break;
                default:
                    printf("Invalid choice! Please try again.\n");
            }
        } while (choice != 6);
    
        return 0;
    }
    
    
    
                 </center>  </code></pre>
                </div>
                <div class="output-container" id="output1">
                    <h2><center>Output</center></h2>
                    <pre><code><center>
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter value to insert: 13
    13 inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 5
    Queue is not full.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter value to insert: 17
    17 inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 2
    13 deleted from the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 3
    Front element is: 17
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 4
    Queue is not empty.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 4
    Queue is not empty.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 6
    Exiting...
    
    
    
               </center> </code></pre>
                </div>
    
                <div class="code-container" id="code2" style="display:none;">
                    <h2><center>Code for Question 2</center></h2>
                    <pre><code><center>
    
    #include < stdio.h >
    
    #define MAX 5    
    #define STRING_LENGTH 100 
    
    
    int isEmpty(int front) {
        return (front == -1);
    }
    
    int isFull(int rear) {
        return (rear == MAX - 1);
    }
    
    void insert(char queue[MAX][STRING_LENGTH], int *rear, char value[]) {
        if (isFull(*rear)) {
            printf("Queue is full! Cannot insert \"%s\".\n", value);
        } else {
            if (isEmpty(*rear)) {
                *rear = 0; 
            } else {
                (*rear)++;
            }
            
            for (int i = 0; value[i] != '\0' && i < STRING_LENGTH - 1; i++) {
                queue[*rear][i] = value[i];
            }
            queue[*rear][STRING_LENGTH - 1] = '\0'; 
            printf("\"%s\" inserted into the queue.\n", queue[*rear]);
        }
    }
    
    void delete(char queue[MAX][STRING_LENGTH], int *front, int *rear) {
        if (isEmpty(*front)) {
            printf("Queue is empty! Cannot delete.\n");
        } else {
            printf("\"%s\" deleted from the queue.\n", queue[*front]);
            if (*front == *rear) {
                
                *front = -1;
                *rear = -1;
            } else {
                (*front)++;
            }
        }
    }
    
    char* peek(char queue[MAX][STRING_LENGTH], int front) {
        if (isEmpty(front)) {
            printf("Queue is empty! Nothing to peek.\n");
            return NULL;
        } else {
            return queue[front];
        }
    }
    
    int main() {
        char queue[MAX][STRING_LENGTH]; 
        int front = -1;  
        int rear = -1;   
        int choice;
        char value[STRING_LENGTH];
    
        do {
            printf("\nQueue Operations Menu:\n");
            printf("1. Insert\n");
            printf("2. Delete\n");
            printf("3. Peek\n");
            printf("4. Check if Empty\n");
            printf("5. Check if Full\n");
            printf("6. Exit\n");
            printf("Enter your choice: ");
            scanf("%d", &choice);
            getchar();   
    
            switch (choice) {
                case 1:
                    printf("Enter string to insert: ");
                    fgets(value, STRING_LENGTH, stdin);
                   
                    for (int i = 0; value[i] != '\0'; i++) {
                        if (value[i] == '\n') {
                            value[i] = '\0';
                        }
                    }
                    insert(queue, &rear, value);
                    if (front == -1) { 
                        front = 0;
                    }
                    break;
                case 2: 
                    delete(queue, &front, &rear);
                    break;
                case 3: 
                    {
                        char* frontValue = peek(queue, front);
                        if (frontValue != NULL) {
                            printf("Front element is: \"%s\"\n", frontValue);
                        }
                    }
                    break;
                case 4: 
                    if (isEmpty(front)) {
                        printf("Queue is empty.\n");
                    } else {
                        printf("Queue is not empty.\n");
                    }
                    break;
                case 5:
                    if (isFull(rear)) {
                        printf("Queue is full.\n");
                    } else {
                        printf("Queue is not full.\n");
                    }
                    break;
                case 6: 
                    printf("Exiting...\n");
                    break;
                default:
                    printf("Invalid choice! Please try again.\n");
            }
        } while (choice != 6);
    
        return 0;
    }
    
               
    
    
                 </center>   </code></pre>
                </div>
                <div class="output-container" id="output2" style="display:none;">
                    <h2><center>Output</center></h2>
                    <pre><code><center>
    
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter string to insert: h
    "h" inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter string to insert: e
    "e" inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter string to insert: l
    "l" inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 2
    "h" deleted from the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 3
    Front element is: "e"
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 5
    Queue is not full.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 4
    Queue is not empty.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 6
    Exiting...
    
                   </center> </code></pre>
                </div>
    
                <div class="code-container" id="code3" style="display:none;">
                    <h2><center>Code for Question 3</center></h2>
                    <pre><code><center>
    
    
    #include < stdio.h >
    #include < stdlib.h >
    
    typedef struct Queue {
        int *array;   
        int front;   
        int rear;     
        int capacity; 
    } Queue;
    
    
    Queue* createQueue(int capacity) {
        Queue* q = (Queue*)malloc(sizeof(Queue));
        q->capacity = capacity;
        q->front = -1;
        q->rear = -1;
        q->array = (int*)malloc(q->capacity * sizeof(int));
        return q;
    }
    
    
    int isEmpty(Queue* q) {
        return (q->front == -1);
    }
    int isFull(Queue* q) {
        return (q->rear == q->capacity - 1);
    }
    
    
    void insert(Queue* q, int value) {
        if (isFull(q)) {
            printf("Queue is full! Cannot insert %d.\n", value);
        } else {
            if (isEmpty(q)) {
                q->front = 0; // First element inserted
            }
            q->rear++;
            q->array[q->rear] = value;
            printf("%d inserted into the queue.\n", value);
        }
    }
    
    
    int delete(Queue* q) {
        if (isEmpty(q)) {
            printf("Queue is empty! Cannot delete.\n");
            return -1; 
        } else {
            int value = q->array[q->front];
           
            if (q->front == q->rear) {
                q->front = -1;
                q->rear = -1;
            } else {
                q->front++;
            }
            printf("%d deleted from the queue.\n", value);
            return value;
        }
    }
    
    
    int peek(Queue* q) {
        if (isEmpty(q)) {
            printf("Queue is empty! Nothing to peek.\n");
            return -1; 
        } else {
            return q->array[q->front];
        }
    }
    
    
    void freeQueue(Queue* q) {
        free(q->array);
        free(q);
    }
    
    
    int main() {
        int capacity;
        printf("Enter the maximum size of the queue: ");
        scanf("%d", &capacity);
        
        Queue* q = createQueue(capacity);
        
        int choice, value;
    
        do {
            printf("\nQueue Operations Menu:\n");
            printf("1. Insert\n");
            printf("2. Delete\n");
            printf("3. Peek\n");
            printf("4. Check if Empty\n");
            printf("5. Check if Full\n");
            printf("6. Exit\n");
            printf("Enter your choice: ");
            scanf("%d", &choice);
    
            switch (choice) {
                case 1:
                    printf("Enter value to insert: ");
                    scanf("%d", &value);
                    insert(q, value);
                    break;
                case 2:
                    delete(q);
                    break;
                case 3: 
                    value = peek(q);
                    if (value != -1) {
                        printf("Front element is: %d\n", value);
                    }
                    break;
                case 4: 
                    if (isEmpty(q)) {
                        printf("Queue is empty.\n");
                    } else {
                        printf("Queue is not empty.\n");
                    }
                    break;
                case 5: 
                    if (isFull(q)) {
                        printf("Queue is full.\n");
                    } else {
                        printf("Queue is not full.\n");
                    }
                    break;
                case 6: 
                    printf("Exiting...\n");
                    break;
                default:
                    printf("Invalid choice! Please try again.\n");
            }
        } while (choice != 6);
    
        freeQueue(q); 
        return 0;
    }
    
                    </center></code></pre>
                </div>
                <div class="output-container" id="output3" style="display:none;">
                    <h2><center>Output</center></h2>
                    <pre><code><center>
    
    
    Enter the maximum size of the queue: 5
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter value to insert: 23
    23 inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter value to insert: 34
    34 inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 2
    23 deleted from the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 3
    Front element is: 34
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 5
    Queue is not full.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter value to insert: 34
    34 inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter value to insert: 89
    89 inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter value to insert: 67
    67 inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter value to insert: 6
    Queue is full! Cannot insert 6.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 6
    Exiting...
    
    
    
                    </center></code></pre>
                </div>
    <div class="code-container" id="code4" style="display:none;">
                    <h2><center>Code for Question 4</center></h2>
                    <pre><code><center>
    
    #include < stdio.h >
    #include < stdlib.h >
    #include < string.h >
    
    typedef struct Queue {
        char **array;  
        int front;     
        int rear;      
        int capacity;   
    } Queue;
    
    
    Queue* createQueue(int capacity) {
        Queue* q = (Queue*)malloc(sizeof(Queue));
        q->capacity = capacity;
        q->front = -1;
        q->rear = -1;
        q->array = (char*)malloc(q->capacity * sizeof(char));
        return q;
    }
    
    
    int isEmpty(Queue* q) {
        return (q->front == -1);
    }
    
    int isFull(Queue* q) {
        return (q->rear == q->capacity - 1);
    }
    void insert(Queue* q, const char* value) {
        if (isFull(q)) {
            printf("Queue is full! Cannot insert \"%s\".\n", value);
        } else {
            if (isEmpty(q)) {
                q->front = 0; 
            }
            q->rear++;
            
            q->array[q->rear] = (char*)malloc((strlen(value) + 1) * sizeof(char));
            strcpy(q->array[q->rear], value);
            printf("\"%s\" inserted into the queue.\n", q->array[q->rear]);
        }
    }
    
    
    char* delete(Queue* q) {
        if (isEmpty(q)) {
            printf("Queue is empty! Cannot delete.\n");
            return NULL;
        } else {
            char* value = q->array[q->front];
            printf("\"%s\" deleted from the queue.\n", value);
            if (q->front == q->rear) {
                
                q->front = -1;
                q->rear = -1;
            } else {
                q->front++;
            }
            return value; 
        }
    }
    
    
    char* peek(Queue* q) {
        if (isEmpty(q)) {
            printf("Queue is empty! Nothing to peek.\n");
            return NULL; 
        } else {
            return q->array[q->front];
        }
    }
    
    
    void freeQueue(Queue* q) {
        for (int i = q->front; i <= q->rear; i++) {
            free(q->array[i]); // Free each string
        }
        free(q->array);
        free(q);
    }
    int main() {
        int capacity;
        printf("Enter the maximum size of the queue: ");
        scanf("%d", &capacity);
        getchar(); 
        Queue* q = createQueue(capacity);
        
        int choice;
        char value[100]; 
    
        do {
            printf("\nQueue Operations Menu:\n");
            printf("1. Insert\n");
            printf("2. Delete\n");
            printf("3. Peek\n");
            printf("4. Check if Empty\n");
            printf("5. Check if Full\n");
            printf("6. Exit\n");
            printf("Enter your choice: ");
            scanf("%d", &choice);
            getchar(); 
    
            switch (choice) {
                case 1: 
                    printf("Enter string to insert: ");
                    fgets(value, sizeof(value), stdin);
                    
                    value[strcspn(value, "\n")] = 0;
                    insert(q, value);
                    break;
                case 2:
                    {
                        char* deletedValue = delete(q);
                        if (deletedValue != NULL) {
                            free(deletedValue); 
                        }
                    }
                    break;
                case 3: 
                    {
                        char* frontValue = peek(q);
                        if (frontValue != NULL) {
                            printf("Front element is: \"%s\"\n", frontValue);
                        }
                    }
                    break;
                case 4: 
                    if (isEmpty(q)) {
                        printf("Queue is empty.\n");
                    } else {
                        printf("Queue is not empty.\n");
                    }
                    break;
                case 5: 
                    if (isFull(q)) {
                        printf("Queue is full.\n");
                    } else {
                        printf("Queue is not full.\n");
                    }
                    break;
                case 6: 
                    printf("Exiting...\n");
                    break;
                default:
                    printf("Invalid choice! Please try again.\n");
            }
        } while (choice != 6);
    
        freeQueue(q); 
        return 0;
    }
        
    
    
    </center></code></pre>
                </div>
    
     <div class="output-container" id="output4" style="display:none;">
                    <h2><center>Output</center></h2>
                    <pre><code><center>
    Enter the maximum size of the queue: 6
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter string to insert: hello
    "hello" inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 1
    Enter string to insert: program
    "program" inserted into the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 2
    "hello" deleted from the queue.
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 3
    Front element is: "program"
    
    Queue Operations Menu:
    1. Insert
    2. Delete
    3. Peek
    4. Check if Empty
    5. Check if Full
    6. Exit
    Enter your choice: 6
    Exiting...
    
    
     </center></code></pre>
                </div>
<div class="code-container" id="code5" style="display:none;">
        <h2><center>Code for Question 5</center></h2>
        <pre><code><center>
#include < stdio.h >
#define MAX 5  

typedef struct CircularQueue {
int array[MAX]; 
int front;   
int rear;       
} CircularQueue;


void initializeQueue(CircularQueue* q) {
q->front = -1;
q->rear = -1;
}


int isEmpty(CircularQueue* q) {
return (q->front == -1);
}

int isFull(CircularQueue* q) {
return ((q->rear + 1) % MAX == q->front);
}


void insert(CircularQueue* q, int value) {
if (isFull(q)) {
printf("Queue is full! Cannot insert %d.\n", value);
} else {
if (isEmpty(q)) {
    q->front = 0; 
}
q->rear = (q->rear + 1) % MAX; 
q->array[q->rear] = value;
printf("%d inserted into the queue.\n", value);
}
}

int delete(CircularQueue* q) {
if (isEmpty(q)) {
printf("Queue is empty! Cannot delete.\n");
return -1; 
} else {
int value = q->array[q->front];
printf("%d deleted from the queue.\n", value);
if (q->front == q->rear) {
    
    q->front = -1;
    q->rear = -1;
} else {
    q->front = (q->front + 1) % MAX; 
}
return value; 
}
}


int peek(CircularQueue* q) {
if (isEmpty(q)) {
printf("Queue is empty! Nothing to peek.\n");
return -1; 
} else {
return q->array[q->front];
}
}


int main() {
CircularQueue q;
initializeQueue(&q);

int choice, value;

do {
printf("\nCircular Queue Operations Menu:\n");
printf("1. Insert\n");
printf("2. Delete\n");
printf("3. Peek\n");
printf("4. Check if Empty\n");
printf("5. Check if Full\n");
printf("6. Exit\n");
printf("Enter your choice: ");
scanf("%d", &choice);

switch (choice) {
    case 1: 
        printf("Enter value to insert: ");
        scanf("%d", &value);
        insert(&q, value);
        break;
    case 2: 
        delete(&q);
        break;
    case 3:
        value = peek(&q);
        if (value != -1) {
            printf("Front element is: %d\n", value);
        }
        break;
    case 4: 
        if (isEmpty(&q)) {
            printf("Queue is empty.\n");
        } else {
            printf("Queue is not empty.\n");
        }
        break;
    case 5: 
        if (isFull(&q)) {
            printf("Queue is full.\n");
        } else {
            printf("Queue is not full.\n");
        }
        break;
    case 6: 
        printf("Exiting...\n");
        break;
    default:
        printf("Invalid choice! Please try again.\n");
}
} while (choice != 6);

return 0;
}



</center></code></pre>
    </div>
<div class="output-container" id="output5" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>

Enter the maximum size of the queue: 5

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 10
10 inserted into the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 20
20 inserted into the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 30
30 inserted into the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 40
40 inserted into the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 50
50 inserted into the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 60
Queue is full! Cannot insert 60.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
Front element is: 10

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 2
10 deleted from the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
Front element is: 20

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 4
Queue is not empty.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 5
Queue is not full.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 6
Exiting...



</center></code></pre>
    </div>
<div class="code-container" id="code6" style="display:none;">
        <h2><center>Code for Question 6</center></h2>
        <pre><code><center>
#include < stdio.h >
#include < stdlib.h >
#include < string.h >

#define MAX 5  
#define STRING_LENGTH 100 

typedef struct CircularQueue {
char array[MAX][STRING_LENGTH]; 
int front;                      
int rear;                       
} CircularQueue;


void initializeQueue(CircularQueue* q) {
q->front = -1;
q->rear = -1;
}


int isEmpty(CircularQueue* q) {
return (q->front == -1);
}


int isFull(CircularQueue* q) {
return ((q->rear + 1) % MAX == q->front);
}


void insert(CircularQueue* q, const char* value) {
if (isFull(q)) {
printf("Queue is full! Cannot insert \"%s\".\n", value);
} else {
if (isEmpty(q)) {
    q->front = 0; 
}
q->rear = (q->rear + 1) % MAX; 
strcpy(q->array[q->rear], value);
printf("\"%s\" inserted into the queue.\n", value);
}
}


char* delete(CircularQueue* q) {
if (isEmpty(q)) {
printf("Queue is empty! Cannot delete.\n");
return NULL; 
} else {
char* value = q->array[q->front];
printf("\"%s\" deleted from the queue.\n", value);
if (q->front == q->rear) {

    q->front = -1;
    q->rear = -1;
} else {
    q->front = (q->front + 1) % MAX; 
}
return value; 
}
}


char* peek(CircularQueue* q) {
if (isEmpty(q)) {
printf("Queue is empty! Nothing to peek.\n");
return NULL; 
} else {
return q->array[q->front];
}
}


void freeQueue(CircularQueue* q) {



int main() {
CircularQueue q;
initializeQueue(&q);

int choice;
char value[STRING_LENGTH]; 

do {
printf("\nCircular Queue Operations Menu:\n");
printf("1. Insert\n");
printf("2. Delete\n");
printf("3. Peek\n");
printf("4. Check if Empty\n");
printf("5. Check if Full\n");
printf("6. Exit\n");
printf("Enter your choice: ");
scanf("%d", &choice);
getchar(); 

switch (choice) {
    case 1: 
        printf("Enter string to insert: ");
        fgets(value, sizeof(value), stdin);
       
        value[strcspn(value, "\n")] = 0;
        insert(&q, value);
        break;
    case 2: 
        {
            char* deletedValue = delete(&q);
            
        }
        break;
    case 3: 
        {
            char* frontValue = peek(&q);
            if (frontValue != NULL) {
                printf("Front element is: \"%s\"\n", frontValue);
            }
        }
        break;
    case 4: 
        if (isEmpty(&q)) {
            printf("Queue is empty.\n");
        } else {
            printf("Queue is not empty.\n");
        }
        break;
    case 5: 
        if (isFull(&q)) {
            printf("Queue is full.\n");
        } else {
            printf("Queue is not full.\n");
        }
        break;
    case 6: 
        printf("Exiting...\n");
        break;
    default:
        printf("Invalid choice! Please try again.\n");
}
} while (choice != 6);

return 0;
}

</center></code></pre>
    </div>
<div class="output-container" id="output6" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Hello
"Hello" inserted into the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: World
"World" inserted into the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: This is a test
"This is a test" inserted into the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Circular Queue
"Circular Queue" inserted into the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Data Structure
"Data Structure" inserted into the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Overflow
Queue is full! Cannot insert "Overflow".

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
Front element is: "Hello"

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 2
"Hello" deleted from the queue.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
Front element is: "World"

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 4
Queue is not empty.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 5
Queue is not full.

Circular Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 6
Exiting...


</center></code></pre>
    </div>

<div class="code-container" id="code7" style="display:none;">
        <h2><center>Code for Question 7</center></h2>
        <pre><code><center>

#include < stdio.h >
#include < stdlib.h >

#define MAX 5  

typedef struct PriorityQueue {
int array[MAX]; 
int size;       
} PriorityQueue;


void initializeQueue(PriorityQueue* pq) {
pq->size = 0;
}


int isEmpty(PriorityQueue* pq) {
return (pq->size == 0);
}


int isFull(PriorityQueue* pq) {
return (pq->size == MAX);
}


void insert(PriorityQueue* pq, int value) {
if (isFull(pq)) {
printf("Priority Queue is full! Cannot insert %d.\n", value);
return;
}

int i = pq->size - 1;


while (i >= 0 && pq->array[i] < value) {
pq->array[i + 1] = pq->array[i]; 
i--;
}
pq->array[i + 1] = value; 
pq->size++;
printf("%d inserted into the priority queue.\n", value);
}


int delete(PriorityQueue* pq) {
if (isEmpty(pq)) {
printf("Priority Queue is empty! Cannot delete.\n");
return -1; 
}

int value = pq->array[0]; 
printf("%d deleted from the priority queue.\n", value);


for (int i = 0; i < pq->size - 1; i++) {
pq->array[i] = pq->array[i + 1];
}
pq->size--; 
return value; 
}


int peek(PriorityQueue* pq) {
if (isEmpty(pq)) {
printf("Priority Queue is empty! Nothing to peek.\n");
return -1; 
}
return pq->array[0];
}


int main() {
PriorityQueue pq;
initializeQueue(&pq);

int choice, value;

do {
printf("\nPriority Queue Operations Menu:\n");
printf("1. Insert\n");
printf("2. Delete\n");
printf("3. Peek\n");
printf("4. Check if Empty\n");
printf("5. Check if Full\n");
printf("6. Exit\n");
printf("Enter your choice: ");
scanf("%d", &choice);

switch (choice) {
    case 1: 
        printf("Enter value to insert: ");
        scanf("%d", &value);
        insert(&pq, value);
        break;
    case 2: 
        delete(&pq);
        break;
    case 3: 
        value = peek(&pq);
        if (value != -1) {
            printf("Highest priority element is: %d\n", value);
        }
        break;
    case 4: 
        if (isEmpty(&pq)) {
            printf("Priority Queue is empty.\n");
        } else {
            printf("Priority Queue is not empty.\n");
        }
        break;
    case 5: 
        if (isFull(&pq)) {
            printf("Priority Queue is full.\n");
        } else {
            printf("Priority Queue is not full.\n");
        }
        break;
    case 6: 
        printf("Exiting...\n");
        break;
    default:
        printf("Invalid choice! Please try again.\n");
}
} while (choice != 6);

return 0;
}


</center></code></pre>
    </div>

<div class="output-container" id="output7" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 5
5 inserted into the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 3
3 inserted into the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 8
8 inserted into the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 1
1 inserted into the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 10
10 inserted into the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter value to insert: 6
Priority Queue is full! Cannot insert 6.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
Highest priority element is: 10

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 2
10 deleted from the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
Highest priority element is: 8

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 4
Priority Queue is not empty.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 5
Priority Queue is not full.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 6
Exiting...


</center></code></pre>
    </div>

<div class="code-container" id="code8" style="display:none;">
        <h2><center>Code for Question 8</center></h2>
        <pre><code><center>

#include < stdio.h >

#define MAX 5            
#define STRING_LENGTH 100 
typedef struct PriorityQueue {
char array[MAX][STRING_LENGTH]; 
int size;                       
} PriorityQueue;


void initializeQueue(PriorityQueue* pq) {
pq->size = 0;
}


int isEmpty(PriorityQueue* pq) {
return (pq->size == 0);
}


int isFull(PriorityQueue* pq) {
return (pq->size == MAX);
}


int stringCompare(const char* str1, const char* str2) {
while (*str1 && *str2) {
if (*str1 != *str2) {
    return (*str1 - *str2); 
}
str1++;
str2++;
}
return (*str1 - *str2); 
}


void stringCopy(char* dest, const char* src) {
while (*src) {
*dest++ = *src++;
}
*dest = '\0'; 
}


void insert(PriorityQueue* pq, const char* value) {
if (isFull(pq)) {
printf("Priority Queue is full! Cannot insert \"%s\".\n", value);
return;
}

int i = pq->size - 1;


while (i >= 0 && stringCompare(pq->array[i], value) > 0) {
stringCopy(pq->array[i + 1], pq->array[i]); 
i--;
}
stringCopy(pq->array[i + 1], value);
pq->size++;
printf("\"%s\" inserted into the priority queue.\n", value);
}


char* delete(PriorityQueue* pq) {
if (isEmpty(pq)) {
printf("Priority Queue is empty! Cannot delete.\n");
return NULL; 
}

char* value = pq->array[0]; 
printf("\"%s\" deleted from the priority queue.\n", value);


for (int i = 0; i < pq->size - 1; i++) {
stringCopy(pq->array[i], pq->array[i + 1]);
}
pq->size--; 
return value;
}


char* peek(PriorityQueue* pq) {
if (isEmpty(pq)) {
printf("Priority Queue is empty! Nothing to peek.\n");
return NULL;
}
return pq->array[0]; 
}


int main() {
PriorityQueue pq;
initializeQueue(&pq);

int choice;
char value[STRING_LENGTH]; 
do {
printf("\nPriority Queue Operations Menu:\n");
printf("1. Insert\n");
printf("2. Delete\n");
printf("3. Peek\n");
printf("4. Check if Empty\n");
printf("5. Check if Full\n");
printf("6. Exit\n");
printf("Enter your choice: ");
scanf("%d", &choice);
getchar(); 

switch (choice) {
    case 1: 
        printf("Enter string to insert: ");
        fgets(value, sizeof(value), stdin);
        value[stringCompare(value, "\n")] = 0; 
        insert(&pq, value);
        break;
    case 2: 
        delete(&pq);
        break;
    case 3: 
        {
            char* frontValue = peek(&pq);
            if (frontValue != NULL) {
                printf("Highest priority element is: \"%s\"\n", frontValue);
            }
        }
        break;
    case 4: 
        if (isEmpty(&pq)) {
            printf("Priority Queue is empty.\n");
        } else {
            printf("Priority Queue is not empty.\n");
        }
        break;
    case 5: 
        if (isFull(&pq)) {
            printf("Priority Queue is full.\n");
        } else {
            printf("Priority Queue is not full.\n");
        }
        break;
    case 6: 
        printf("Exiting...\n");
        break;
    default:
        printf("Invalid choice! Please try again.\n");
}
} while (choice != 6);

return 0;
}



</center></code></pre>
    </div>

<div class="output-container" id="output8" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Apple
"Apple" inserted into the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Orange
"Orange" inserted into the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Banana
"Banana" inserted into the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Grape
"Grape" inserted into the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Watermelon
"Watermelon" inserted into the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Kiwi
Priority Queue is full! Cannot insert "Kiwi".

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
Highest priority element is: "Apple"

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 2
"Apple" deleted from the priority queue.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
Highest priority element is: "Banana"

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 4
Priority Queue is not empty.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 5
Priority Queue is not full.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 6
Exiting...

</center></code></pre>
    </div>

<div class="code-container" id="code9" style="display:none;">
        <h2><center>Code for Question 9</center></h2>
        <pre><code><center>
#include < stdio.h >

#define MAX 5;
typedef struct Deque {
int array[MAX]; 
int front;      
int rear;       
int size;     
} Deque;


void initializeDeque(Deque* dq) {
dq->front = -1;
dq->rear = -1;
dq->size = 0;
}


int isEmpty(Deque* dq) {
return (dq->size == 0);
}


int isFull(Deque* dq) {
return (dq->size == MAX);
}


void insertFront(Deque* dq, int value) {
if (isFull(dq)) {
printf("Deque is full! Cannot insert %d at front.\n", value);
return;
}

if (isEmpty(dq)) {
dq->front = dq->rear = 0; 
} else {
dq->front = (dq->front - 1 + MAX) % MAX; 
}

dq->array[dq->front] = value;
dq->size++;
printf("%d inserted at the front of the deque.\n", value);
}


void insertRear(Deque* dq, int value) {
if (isFull(dq)) {
printf("Deque is full! Cannot insert %d at rear.\n", value);
return;
}

if (isEmpty(dq)) {
dq->front = dq->rear = 0; 
} else {
dq->rear = (dq->rear + 1) % MAX; 
}

dq->array[dq->rear] = value;
dq->size++;
printf("%d inserted at the rear of the deque.\n", value);
}


int deleteFront(Deque* dq) {
if (isEmpty(dq)) {
printf("Deque is empty! Cannot delete from front.\n");
return -1; // Return -1 if the deque is empty
}

int value = dq->array[dq->front];

if (dq->front == dq->rear) {

dq->front = dq->rear = -1;
} else {
dq->front = (dq->front + 1) % MAX; 
}

dq->size--;
printf("%d deleted from the front of the deque.\n", value);
return value;
}


int deleteRear(Deque* dq) {
if (isEmpty(dq)) {
printf("Deque is empty! Cannot delete from rear.\n");
return -1; 
}

int value = dq->array[dq->rear];

if (dq->front == dq->rear) {
// Only one element was present
dq->front = dq->rear = -1;
} else {
dq->rear = (dq->rear - 1 + MAX) % MAX; 
}

dq->size--;
printf("%d deleted from the rear of the deque.\n", value);
return value;
}


int peekFront(Deque* dq) {
if (isEmpty(dq)) {
printf("Deque is empty! Nothing to peek from front.\n");
return -1; 
}
return dq->array[dq->front]; 
}


int peekRear(Deque* dq) {
if (isEmpty(dq)) {
printf("Deque is empty! Nothing to peek from rear.\n");
return -1;
}
return dq->array[dq->rear];
}


int main() {
Deque dq;
initializeDeque(&dq);

int choice, value;

do {
printf("\nDouble-Ended Queue Operations Menu:\n");
printf("1. Insert at Front\n");
printf("2. Insert at Rear\n");
printf("3. Delete from Front\n");
printf("4. Delete from Rear\n");
printf("5. Peek Front\n");
printf("6. Peek Rear\n");
printf("7. Check if Empty\n");
printf("8. Check if Full\n");
printf("9. Exit\n");
printf("Enter your choice: ");
scanf("%d", &choice);

switch (choice) {
    case 1: 
        printf("Enter integer to insert at front: ");
        scanf("%d", &value);
        insertFront(&dq, value);
        break;
    case 2: 
        printf("Enter integer to insert at rear: ");
        scanf("%d", &value);
        insertRear(&dq, value);
        break;
    case 3: 
        deleteFront(&dq);
        break;
    case 4: 
        deleteRear(&dq);
        break;
    case 5: 
        {
            int frontValue = peekFront(&dq);
            if (frontValue != -1) {
                printf("Front element is: %d\n", frontValue);
            }
        }
        break;
    case 6: 
        {
            int rearValue = peekRear(&dq);
            if (rearValue != -1) {
                printf("Rear element is: %d\n", rearValue);
            }
        }
        break;
    case 7: 
        if (isEmpty(&dq)) {
            printf("Deque is empty.\n");
        } else {
            printf("Deque is not empty.\n");
        }
        break;
    case 8:
        if (isFull(&dq)) {
            printf("Deque is full.\n");
        } else {
            printf("Deque is not full.\n");
        }
        break;
    case 9:
        printf("Exiting...\n");
        break;
    default:
        printf("Invalid choice! Please try again.\n");
}
} while (choice != 9);

return 0;
}




</center></code></pre>
    </div>

<div class="output-container" id="output9" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 1
Enter integer to insert at front: 10
10 inserted at the front of the deque.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 2
Enter integer to insert at rear: 20
20 inserted at the rear of the deque.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 1
Enter integer to insert at front: 5
5 inserted at the front of the deque.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 5
Front element is: 5

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 6
Rear element is: 20

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 3
5 deleted from the front of the deque.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 4
20 deleted from the rear of the deque.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 7
Deque is empty.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 9
Exiting...

</center></code></pre>
    </div>

<div class="code-container" id="code10" style="display:none;">
        <h2><center>Code for Question 10</center></h2>
        <pre><code><center>

#include < stdio.h >

#define MAX 5           
#define STRING_LENGTH 100 

typedef struct Deque {
char array[MAX][STRING_LENGTH]; 
int front;                      
int rear;                       
int size;                       
} Deque;


void initializeDeque(Deque* dq) {
dq->front = -1;
dq->rear = -1;
dq->size = 0;
}


int isEmpty(Deque* dq) {
return (dq->size == 0);
}


int isFull(Deque* dq) {
return (dq->size == MAX);
}


void stringCopy(char* dest, const char* src) {
while (*src) {
*dest++ = *src++;
}
*dest = '\0'; 
}


void insertFront(Deque* dq, const char* value) {
if (isFull(dq)) {
printf("Deque is full! Cannot insert \"%s\" at front.\n", value);
return;
}

if (isEmpty(dq)) {
dq->front = dq->rear = 0;
} else {
dq->front = (dq->front - 1 + MAX) % MAX; 
}

stringCopy(dq->array[dq->front], value); 
dq->size++;
printf("\"%s\" inserted at the front of the deque.\n", value);
}


void insertRear(Deque* dq, const char* value) {
if (isFull(dq)) {
printf("Deque is full! Cannot insert \"%s\" at rear.\n", value);
return;
}

if (isEmpty(dq)) {
dq->front = dq->rear = 0; 
} else {
dq->rear = (dq->rear + 1) % MAX; 
}

stringCopy(dq->array[dq->rear], value); 
dq->size++;
printf("\"%s\" inserted at the rear of the deque.\n", value);
}


char* deleteFront(Deque* dq) {
if (isEmpty(dq)) {
printf("Deque is empty! Cannot delete from front.\n");
return NULL; 
}

char* value = dq->array[dq->front]; 

if (dq->front == dq->rear) {

dq->front = dq->rear = -1;
} else {
dq->front = (dq->front + 1) % MAX; 
}

dq->size--;
printf("\"%s\" deleted from the front of the deque.\n", value);
return value; 
}


char* deleteRear(Deque* dq) {
if (isEmpty(dq)) {
printf("Deque is empty! Cannot delete from rear.\n");
return NULL; 
}

char* value = dq->array[dq->rear]; 

if (dq->front == dq->rear) {

dq->front = dq->rear = -1;
} else {
dq->rear = (dq->rear - 1 + MAX) % MAX; 
}

dq->size--;
printf("\"%s\" deleted from the rear of the deque.\n", value);
return value; 
}


char* peekFront(Deque* dq) {
if (isEmpty(dq)) {
printf("Deque is empty! Nothing to peek from front.\n");
return NULL; 
}
return dq->array[dq->front]; 
}


char* peekRear(Deque* dq) {
if (isEmpty(dq)) {
printf("Deque is empty! Nothing to peek from rear.\n");
return NULL; 
}
return dq->array[dq->rear]; 
}


int main() {
Deque dq;
initializeDeque(&dq);

int choice;
char value[STRING_LENGTH]; 

do {
printf("\nDouble-Ended Queue Operations Menu:\n");
printf("1. Insert at Front\n");
printf("2. Insert at Rear\n");
printf("3. Delete from Front\n");
printf("4. Delete from Rear\n");
printf("5. Peek Front\n");
printf("6. Peek Rear\n");
printf("7. Check if Empty\n");
printf("8. Check if Full\n");
printf("9. Exit\n");
printf("Enter your choice: ");
scanf("%d", &choice);
getchar(); 
switch (choice) {
    case 1: 
        printf("Enter string to insert at front: ");
        fgets(value, sizeof(value), stdin);
        
        value[strcspn(value, "\n")] = 0; 
        insertFront(&dq, value);
        break;
    case 2: 
        printf("Enter string to insert at rear: ");
        fgets(value, sizeof(value), stdin);
        
        value[strcspn(value, "\n")] = 0; 
        insertRear(&dq, value);
        break;
    case 3: 
        deleteFront(&dq);
        break;
    case 4: 
        deleteRear(&dq);
        break;
    case 5: 
        {
            char* frontValue = peekFront(&dq);
            if (frontValue != NULL) {
                printf("Front element is: \"%s\"\n", frontValue);
            }
        }
        break;
    case 6: 
        {
            char* rearValue = peekRear(&dq);
            if (rearValue != NULL) {
                printf("Rear element is: \"%s\"\n", rearValue);
            }
        }
        break;
    case 7: 
        if (isEmpty(&dq)) {
            printf("Deque is empty.\n");
        } else {
            printf("Deque is not empty.\n");
        }
        break;
    case 8: 
        if (isFull(&dq)) {
            printf("Deque is full.\n");
        } else {
            printf("Deque is not full.\n");
        }
        break;
    case 9: 
        printf("Exiting...\n");
        break;
    default:
        printf("Invalid choice! Please try again.\n");
}
} while (choice != 9);

return 0;
}

</center></code></pre>
    </div>

<div class="output-container" id="output10" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 1
Enter string to insert at front: Hello
"Hello" inserted at the front of the deque.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 2
Enter string to insert at rear: World
"World" inserted at the rear of the deque.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 1
Enter string to insert at front: Goodbye
"Goodbye" inserted at the front of the deque.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 5
Front element is: "Goodbye"

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 6
Rear element is: "World"

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 3
"Goodbye" deleted from the front of the deque.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 4
"World" deleted from the rear of the deque.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 7
Deque is empty.

Double-Ended Queue Operations Menu:
1. Insert at Front
2. Insert at Rear
3. Delete from Front
4. Delete from Rear
5. Peek Front
6. Peek Rear
7. Check if Empty
8. Check if Full
9. Exit
Enter your choice: 9
Exiting...



</center></code></pre>
    </div>
    <div class="code-container" id="code11" style="display:none;">
        <h2><center>Code for Question 11</center></h2>
        <pre><code><center>

#include < stdio.h >
#include < stdlib.h >

typedef struct Node {
int data;                 
int priority;             
struct Node* next;     
} Node;

typedef struct PriorityQueue {
Node* front;           
} PriorityQueue;


Node* createNode(int data, int priority) {
Node* newNode = (Node*)malloc(sizeof(Node));
newNode->data = data;
newNode->priority = priority;
newNode->next = NULL;
return newNode;
}


void initializeQueue(PriorityQueue* pq) {
pq->front = NULL;
}


int isEmpty(PriorityQueue* pq) {
return (pq->front == NULL);
}


void insert(PriorityQueue* pq, int data, int priority) {
Node* newNode = createNode(data, priority);

if (isEmpty(pq) || pq->front->priority < priority) {

newNode->next = pq->front;
pq->front = newNode;
} else {

Node* current = pq->front;
while (current->next != NULL && current->next->priority >= priority) {
    current = current->next;
}
newNode->next = current->next;
current->next = newNode;
}

printf("Inserted %d with priority %d\n", data, priority);
}


int delete(PriorityQueue* pq) {
if (isEmpty(pq)) {
printf("Priority queue is empty! Cannot delete.\n");
return -1; 
}

Node* temp = pq->front;
int deletedData = temp->data;
pq->front = pq->front->next;
free(temp); 

printf("Deleted %d from the priority queue\n", deletedData);
return deletedData;
}


int peek(PriorityQueue* pq) {
if (isEmpty(pq)) {
printf("Priority queue is empty! Nothing to peek.\n");
return -1; 
}

return pq->front->data; 
}


int main() {
PriorityQueue pq;
initializeQueue(&pq);

int choice, data, priority;

do {
printf("\nPriority Queue Operations Menu:\n");
printf("1. Insert\n");
printf("2. Delete\n");
printf("3. Peek\n");
printf("4. Check if Empty\n");
printf("5. Exit\n");
printf("Enter your choice: ");
scanf("%d", &choice);

switch (choice) {
    case 1: 
        printf("Enter integer to insert: ");
        scanf("%d", &data);
        printf("Enter priority (higher number means higher priority): ");
        scanf("%d", &priority);
        insert(&pq, data, priority);
        break;
    case 2: 
        delete(&pq);
        break;
    case 3:
        {
            int frontData = peek(&pq);
            if (frontData != -1) {
                printf("Highest priority element is: %d\n", frontData);
            }
        }
        break;
    case 4: 
        if (isEmpty(&pq)) {
            printf("Priority queue is empty.\n");
        } else {
            printf("Priority queue is not empty.\n");
        }
        break;
    case 5: 
        printf("Exiting...\n");
        break;
    default:
        printf("Invalid choice! Please try again.\n");
}
} while (choice != 5);


while (!isEmpty(&pq)) {
delete(&pq);
}

return 0;
}


</center></code></pre>
    </div>

<div class="output-container" id="output11" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Exit
Enter your choice: 1
Enter integer to insert: 10
Enter priority (higher number means higher priority): 1
Inserted 10 with priority 1

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Exit
Enter your choice: 1
Enter integer to insert: 20
Enter priority (higher number means higher priority): 3
Inserted 20 with priority 3

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Exit
Enter your choice: 1
Enter integer to insert: 15
Enter priority (higher number means higher priority): 2
Inserted 15 with priority 2

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Exit
Enter your choice: 3
Highest priority element is: 20

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Exit
Enter your choice: 2
Deleted 20 from the priority queue

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Exit
Enter your choice: 4
Priority queue is not empty.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Exit
Enter your choice: 5
Exiting...





</center></code></pre>
    </div>
<div class="code-container" id="code12" style="display:none;">
        <h2><center>Code for Question 12</center></h2>
        <pre><code><center>

#include < stdio.h >
#include < stdlib.h >


typedef struct Node {
char* data;                
int priority;              
struct Node* next;         
} Node;

// Priority Queue structure
typedef struct PriorityQueue {
Node* front;              
} PriorityQueue;

Node* createNode(const char* data, int priority) {
Node* newNode = (Node*)malloc(sizeof(Node));


newNode->data = (char*)malloc(100 * sizeof(char)); 
int i = 0;
while (data[i] != '\0' && i < 99) {
newNode->data[i] = data[i];
i++;
}
newNode->data[i] = '\0'; 
newNode->priority = priority;
newNode->next = NULL;
return newNode;
}


void initializeQueue(PriorityQueue* pq) {
pq->front = NULL;
}


int isEmpty(PriorityQueue* pq) {
return (pq->front == NULL);
}


int isFull(PriorityQueue* pq) {
return 0; 
}

void insert(PriorityQueue* pq, const char* data, int priority) {
Node* newNode = createNode(data);

if (isEmpty(pq) || pq->front->priority < priority) {

newNode->next = pq->front;
pq->front = newNode;
} else {

Node* current = pq->front;
while (current->next != NULL && current->next->priority >= priority) {
    current = current->next;
}
newNode->next = current->next;
current->next = newNode;
}

printf("Inserted \"%s\" with priority %d\n", newNode->data, priority);
}


char* delete(PriorityQueue* pq) {
if (isEmpty(pq)) {
printf("Priority queue is empty! Cannot delete.\n");
return NULL; 
}

Node* temp = pq->front;
char* deletedData = temp->data; 
pq->front = pq->front->next;
free(temp);

printf("Deleted \"%s\" from the priority queue\n", deletedData);
return deletedData; 
}


char* peek(PriorityQueue* pq) {
if (isEmpty(pq)) {
printf("Priority queue is empty! Nothing to peek.\n");
return NULL;
}

return pq->front->data;
}


int main() {
PriorityQueue pq;
initializeQueue(&pq);

int choice, priority;
char value[100]; 

do {
printf("\nPriority Queue Operations Menu:\n");
printf("1. Insert\n");
printf("2. Delete\n");
printf("3. Peek\n");
printf("4. Check if Empty\n");
printf("5. Check if Full\n");
printf("6. Exit\n");
printf("Enter your choice: ");
scanf("%d", &choice);
getchar(); 
switch (choice) {
    case 1: 
        printf("Enter string to insert: ");
        int index = 0;
        while ((value[index] = getchar()) != '\n' && index < 99) {
            index++;
        }
        value[index] = '\0';
        printf("Enter priority (higher number means higher priority): ");
        scanf("%d", &priority);
        insert(&pq, value, priority);
        break;
    case 2: 
        delete(&pq);
        break;
    case 3: 
        {
            char* frontData = peek(&pq);
            if (frontData != NULL) {
                printf("Highest priority element is: \"%s\"\n", frontData);
            }
        }
        break;
    case 4: 
        if (isEmpty(&pq)) {
            printf("Priority queue is empty.\n");
        } else {
            printf("Priority queue is not empty.\n");
        }
        break;
    case 5:
        if (isFull(&pq)) {
            printf("Priority queue is full.\n");
        } else {
            printf("Priority queue is not full (dynamic).\n");
        }
        break;
    case 6: 
        printf("Exiting...\n");
        break;
    default:
        printf("Invalid choice! Please try again.\n");
}
} while (choice != 6);


while (!isEmpty(&pq)) {
delete(&pq);
}

return 0;
}

</center></code></pre>
    </div>

<div class="output-container" id="output12" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: Hello
Enter priority (higher number means higher priority): 5
Inserted "Hello" with priority 5

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 1
Enter string to insert: World
Enter priority (higher number means higher priority): 10
Inserted "World" with priority 10

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 3
Highest priority element is: "World"

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 2
Deleted "World" from the priority queue

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 4
Priority queue is not empty.

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 5
Priority queue is not full (dynamic).

Priority Queue Operations Menu:
1. Insert
2. Delete
3. Peek
4. Check if Empty
5. Check if Full
6. Exit
Enter your choice: 6
Exiting...

</center></code></pre>
    </div>

<div class="code-container" id="code13" style="display:none;">
        <h2><center>Code for Question 13</center></h2>
        <pre><code><center>

#include < stdio.h >

int canCompleteCircuit(int petrol[][2], int n) {
int totalPetrol = 0, totalDistance = 0;
int currentPetrol = 0, startIndex = 0;


for (int i = 0; i < n; i++) {
totalPetrol += petrol[i][0];      
totalDistance += petrol[i][1];   
}


if (totalPetrol < totalDistance) {
return -1;
}


for (int i = 0; i < n; i++) {
currentPetrol += petrol[i][0] - petrol[i][1]; 

if (currentPetrol < 0) {
    startIndex = i + 1; 
}
}

return startIndex; 
}


int main() {
int petrol[][2] = {{4, 6}, {6, 5}, {7, 3}, {4, 5}}; // Example input
int n = sizeof(petrol) / sizeof(petrol[0]); // Number of petrol pumps

int result = canCompleteCircuit(petrol, n);
if (result != -1) {
printf("First circular tour can start at index: %d\n", result);
} else {
printf("No circular tour is possible.\n");
}


int petrol2[][2] = {{6, 4}, {3, 6}, {7, 3}};
n = sizeof(petrol2) / sizeof(petrol2[0]);

result = canCompleteCircuit(petrol2, n);
if (result != -1) {
printf("First circular tour can start at index: %d\n", result);
} else {
printf("No circular tour is possible.\n");
}

return 0;
}




</center></code></pre>
    </div>

<div class="output-container" id="output13" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
First circular tour can start at index: 1
First circular tour can start at index: 2


</center></code></pre>
    </div>


<div class="code-container" id="code14" style="display:none;">
        <h2><center>Code for Question 14</center></h2>
        <pre><code><center>

#include < stdio.h >
#include < stdlib.h >

int longestValidParentheses(const char* s) {
int maxLength = 0;          
int* stack = (int*)malloc((strlen(s) + 1) * sizeof(int)); 
int top = -1;               
int lastInvalid = -1;       

for (int i = 0; s[i] != '\0'; i++) {
if (s[i] == '(') {
  
    stack[++top] = i;
} else {
    
    if (top != -1) {
        
        top--; // Pop the top element (opening parenthesis)
        if (top == -1) {
           
            maxLength = (i - lastInvalid > maxLength) ? (i - lastInvalid) : maxLength;
        } else {
            
            maxLength = (i - stack[top] > maxLength) ? (i - stack[top]) : maxLength;
        }
    } else {
        
        lastInvalid = i;
    }
}
}

free(stack); 
return maxLength; 
}


int main() {
const char* input1 = "((()";
const char* input2 = ")()())";
const char* input3 = "()(()))))";

printf("Longest valid parentheses length for \"%s\": %d\n", input1, longestValidParentheses(input1));
printf("Longest valid parentheses length for \"%s\": %d\n", input2, longestValidParentheses(input2));
printf("Longest valid parentheses length for \"%s\": %d\n", input3, longestValidParentheses(input3));

return 0;
}


</center></code></pre>
    </div>
<div class="output-container" id="output14" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
Longest valid parentheses length for "((()": 2
Longest valid parentheses length for ")()())": 4
Longest valid parentheses length for "()(()))))": 6

</center></code></pre>
    </div>

<div class="code-container" id="code15" style="display:none;">
        <h2><center>Code for Question 15</center></h2>
        <pre><code><center>
#include < stdio.h >
#include < stdlib.h >

void nextGreaterElement(int arr[], int n) {
int* result = (int*)malloc(n * sizeof(int));
int* stack = (int*)malloc(n * sizeof(int));  
int top = -1; 


for (int i = 0; i < n; i++) {
result[i] = -1;
}

for (int i = 0; i < n; i++) {

while (top != -1 && arr[i] > arr[stack[top]]) {
    result[stack[top]] = arr[i]; 
    top--; 
}

stack[++top] = i;
}


for (int i = 0; i < n; i++) {
printf("%d ", result[i]);
}
printf("\n");

free(result);
free(stack);  
}


int main() {
int arr1[] = {1, 3, 2, 4};
int n1 = sizeof(arr1) / sizeof(arr1[0]);
printf("Next greater elements for arr1: ");
nextGreaterElement(arr1, n1);

int arr2[] = {6, 8, 0, 1, 3};
int n2 = sizeof(arr2) / sizeof(arr2[0]);
printf("Next greater elements for arr2: ");
nextGreaterElement(arr2, n2);

return 0;
}

</center></code></pre>
    </div>
<div class="output-container" id="output15" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
Next greater elements for arr1: 3 4 4 -1 
Next greater elements for arr2: 8 -1 1 3 -1 


</center></code></pre>
    </div>

    <div class="code-container" id="code16" style="display:none;">
        <h2><center>Code for Question 16</center></h2>
        <pre><code><center>
#include < stdio.h >
#include < stdlib.h >

void nextSmallerElement(int arr[], int n) {
int* result = (int*)malloc(n * sizeof(int)); 
int* stack = (int*)malloc(n * sizeof(int));  
int top = -1; // Stack top pointer


for (int i = 0; i < n; i++) {
result[i] = -1;
}

for (int i = 0; i < n; i++) {

while (top != -1 && arr[i] < arr[stack[top]]) {
    result[stack[top]] = arr[i]; 
    top--; // Pop the top index
}

stack[++top] = i;
}


for (int i = 0; i < n; i++) {
printf("%d ", result[i]);
}
printf("\n");

free(result); 
free(stack); 
}


int main() {
int arr1[] = {4, 8, 5, 2, 25};
int n1 = sizeof(arr1) / sizeof(arr1[0]);
printf("Next smaller elements for arr1: ");
nextSmallerElement(arr1, n1);

int arr2[] = {13, 7, 6, 12};
int n2 = sizeof(arr2) / sizeof(arr2[0]);
printf("Next smaller elements for arr2: ");
nextSmallerElement(arr2, n2);

return 0;
}

</center></code></pre>
    </div>
<div class="output-container" id="output16" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
Next smaller elements for arr1: 2 5 2 -1 -1 
Next smaller elements for arr2: 7 6 -1 -1 


</center></code></pre>
    </div>

<div class="code-container" id="code17" style="display:none;">
        <h2><center>Code for Question 17</center></h2>
        <pre><code><center>
#include < stdio.h >
#include < stdlib.h >

#define MAX_CHAR 256 

void firstNonRepeatingCharacter(char stream[], int n) {
int freq[MAX_CHAR] = {0}; 
char* queue = (char*)malloc(n * sizeof(char));
int front = 0; 
int rear = -1; 
for (int i = 0; i < n; i++) {
char current = stream[i];
freq[current]++; 


if (freq[current] == 1) {
    queue[++rear] = current;
}


while (front <= rear && freq[queue[front]] > 1) {
    front++; 
}


if (front <= rear) {
    printf("%c ", queue[front]);
} else {
    printf("-1 "); 
}
}
printf("\n");

free(queue); 
}

int main() {
char stream1[] = {'a', 'a', 'b', 'c'};
int n1 = sizeof(stream1) / sizeof(stream1[0]);
printf("First non-repeating characters for stream1: ");
firstNonRepeatingCharacter(stream1, n1);

char stream2[] = {'a', 'a', 'c'};
int n2 = sizeof(stream2) / sizeof(stream2[0]);
printf("First non-repeating characters for stream2: ");
firstNonRepeatingCharacter(stream2, n2);

return 0;
}

</center></code></pre>
    </div>
<div class="output-container" id="output17" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
First non-repeating characters for stream1: a -1 b b 
First non-repeating characters for stream2: a -1 c 

</center></code></pre>
    </div>

<div class="code-container" id="code18" style="display:none;">
        <h2><center>Code for Question 18</center></h2>
        <pre><code><center>
#include < stdio.h >
#include < stdlib.h >

typedef struct Queue {
int* arr;
int front;
int rear;
int size;
int capacity;
} Queue;


Queue* createQueue(int capacity) {
Queue* queue = (Queue*)malloc(sizeof(Queue));
queue->capacity = capacity;
queue->front = 0;
queue->size = 0;
queue->rear = capacity - 1;
queue->arr = (int*)malloc(queue->capacity * sizeof(int));
return queue;
}


int isFull(Queue* queue) {
return (queue->size == queue->capacity);
}

int isEmpty(Queue* queue) {
return (queue->size == 0);
}

void enqueue(Queue* queue, int item) {
if (isFull(queue)) return;
queue->rear = (queue->rear + 1) % queue->capacity;
queue->arr[queue->rear] = item;
queue->size++;
}

int dequeue(Queue* queue) {
if (isEmpty(queue)) return -1;
int item = queue->arr[queue->front];
queue->front = (queue->front + 1) % queue->capacity;
queue->size--;
return item;
}

int front(Queue* queue) {
if (isEmpty(queue)) return -1;
return queue->arr[queue->front];
}


void reverseFirstKElements(Queue* queue, int K) {
if (isEmpty(queue) || K > queue->size) return;


int* stack = (int*)malloc(K * sizeof(int));
int count = 0;


while (count < K && !isEmpty(queue)) {
stack[count++] = dequeue(queue);
}


for (int i = count - 1; i >= 0; i--) {
enqueue(queue, stack[i]);
}


for (int i = 0; i < queue->size - count; i++) {
enqueue(queue, dequeue(queue));
}

free(stack); 
}


void printQueue(Queue* queue) {
for (int i = 0; i < queue->size; i++) {
printf("%d ", queue->arr[(queue->front + i) % queue->capacity]);
}
printf("\n");
}


int main() {
Queue* queue = createQueue(100);
int K;

int arr1[] = {5, 3, 1, 2, 3, 4, 5};
K = 3;
for (int i = 0; i < sizeof(arr1) / sizeof(arr1[0]); i++) {
enqueue(queue, arr1[i]);
}
printf("Original Queue: ");
printQueue(queue);
reverseFirstKElements(queue, K);
printf("Queue after reversing first %d elements: ", K);
printQueue(queue);


free(queue->arr);
free(queue);
queue = createQueue(100);


int arr2[] = {4, 4, 4, 3, 2, 1};
K = 4;
for (int i = 0; i < sizeof(arr2) / sizeof(arr2[0]); i++) {
enqueue(queue, arr2[i]);
}
printf("Original Queue: ");
printQueue(queue);
reverseFirstKElements(queue, K);
printf("Queue after reversing first %d elements: ", K);
printQueue(queue);

free(queue->arr);
free(queue);
return 0;
}

</center></code></pre>
    </div>
<div class="output-container" id="output18" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
Original Queue: 5 3 1 2 3 4 5 
Queue after reversing first 3 elements: 3 1 5 2 3 4 5 
Original Queue: 4 4 4 3 2 1 
Queue after reversing first 4 elements: 3 4 4 4 2 1 
</center></code></pre>
    </div>

<div class="code-container" id="code19" style="display:none;">
        <h2><center>Code for Question 19</center></h2>
        <pre><code><center>
#include < stdio.h >
#include < stdlib.h >

typedef struct Queue {
int* arr;
int front;
int rear;
int size;
int capacity;
} Queue;

Queue* createQueue(int capacity) {
Queue* queue = (Queue*)malloc(sizeof(Queue));
queue->capacity = capacity;
queue->front = 0;
queue->size = 0;
queue->rear = capacity - 1;
queue->arr = (int*)malloc(queue->capacity * sizeof(int));
return queue;
}


int isFull(Queue* queue) {
return (queue->size == queue->capacity);
}

int isEmpty(Queue* queue) {
return (queue->size == 0);
}

void enqueue(Queue* queue, int item) {
if (isFull(queue)) return;
queue->rear = (queue->rear + 1) % queue->capacity;
queue->arr[queue->rear] = item;
queue->size++;
}

int dequeue(Queue* queue) {
if (isEmpty(queue)) return -1;
int item = queue->arr[queue->front];
queue->front = (queue->front + 1) % queue->capacity;
queue->size--;
return item;
}


void rev(Queue* queue) {

int* stack = (int*)malloc(queue->size * sizeof(int));
int index = 0;


while (!isEmpty(queue)) {
stack[index++] = dequeue(queue);
}


for (int i = index - 1; i >= 0; i--) {
enqueue(queue, stack[i]);
}

free(stack); 
}


void printQueue(Queue* queue) {
for (int i = 0; i < queue->size; i++) {
printf("%d ", queue->arr[(queue->front + i) % queue->capacity]);
}
printf("\n");
}


int main() {
Queue* queue = createQueue(100);


int arr1[] = {6, 4, 3, 1, 10, 2, 6};
for (int i = 0; i < sizeof(arr1) / sizeof(arr1[0]); i++) {
enqueue(queue, arr1[i]);
}
printf("Original Queue: ");
printQueue(queue);
rev(queue);
printf("Reversed Queue: ");
printQueue(queue);


free(queue->arr);
free(queue);
queue = createQueue(100);


int arr2[] = {4, 4, 3, 2, 1};
for (int i = 0; i < sizeof(arr2) / sizeof(arr2[0]); i++) {
enqueue(queue, arr2[i]);
}
printf("Original Queue: ");
printQueue(queue);
rev(queue);
printf("Reversed Queue: ");
printQueue(queue);

free(queue->arr);
free(queue);
return 0;
}

</center></code></pre>
    </div>
<div class="output-container" id="output19" style="display:none;">
        <h2><center>Output</center></h2>
        <pre><code><center>
Original Queue: 6 4 3 1 10 2 6 
Reversed Queue: 6 2 10 1 3 4 
Original Queue: 4 4 3 2 1 
Reversed Queue: 1 2 3 4 

</center></code></pre>
    </div>

<div class="code-container" id="code20" style="display:none;">
        <h2>Code</h2>
        <pre><code><center>
#include < stdio.h >
#include < stdlib.h >

#define MAX 100

typedef struct {
int x;
int y;
} Point;

int isValid(int i, int j, int n, int m) {
return (i >= 0 && i < n && j >= 0 && j < m);
}


int orangesRotting(int grid[MAX][MAX], int n, int m) {
Point queue[MAX * MAX]; // Queue for BFS
int front = 0, rear = 0;
int time = 0, freshCount = 0;


for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
    if (grid[i][j] == 2) {
        queue[rear++] = (Point){i, j}; 
    } else if (grid[i][j] == 1) {
        freshCount++; 
    }
}
}


int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

while (front < rear) {
int size = rear - front;
for (int i = 0; i < size; i++) {
    Point current = queue[front++];
    for (int d = 0; d < 4; d++) {
        int newX = current.x + directions[d][0];
        int newY = current.y + directions[d][1];
        if (isValid(newX, newY, n, m) && grid[newX][newY] == 1) {
            grid[newX][newY] = 2; 
            queue[rear++] = (Point){newX, newY}; 
            freshCount--; 
        }
    }
}
if (rear > front) { 
    time++;
}
}

return freshCount == 0 ? time : -1; 
}


int main() {
int grid1[MAX][MAX] = {{0, 1, 2}, {0, 1, 2}, {2, 1, 1}};
int result1 = orangesRotting(grid1, 3, 3);
printf("Output: %d\n", result1); 

int grid2[MAX][MAX] = {{2, 2, 0, 1}};
int result2 = orangesRotting(grid2, 1, 4);
printf("Output: %d\n", result2); 

return 0;
}

</center></code></pre>
    </div>
<div class="output-container" id="output20" style="display:none;">
        <h2>Output></h2>
        <pre><code><center>
Output: 1
Output: -1
</center></code></pre>
    </div>
</div>
</div>
</body>
</html>
    